from airflow import DAG
from airflow.operators.python import PythonOperator
from datetime import datetime
import requests
import json
from dags.get_database_conn import get_cursor, close_connection
from airflow.models import Variable
from pathlib import Path

def create_season_table():

    cursor = get_cursor()

    season_table_sql = """
        BEGIN
            EXECUTE IMMEDIATE '
                CREATE TABLE SEASONS (
                    SEASON_ID INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    SEASON_YEAR INTEGER NOT NULL
                )
            ';
        EXCEPTION
            WHEN OTHERS THEN
                IF SQLCODE != -955 THEN RAISE; END IF;
        END;
    """

    cursor.execute(season_table_sql)

    close_connection()

def fetch_seasons_from_api():

    api_key = Variable.get('API_KEY')
    base_url = Variable.get('BASE_URL')
    
    headers = {
    'x-rapidapi-host': 'v3.football.api-sports.io',
    'x-rapidapi-key': api_key
    }

    response = requests.get(f'{base_url}/leagues/seasons', headers=headers)

    if response.status_code == 200:
        seasons = response.json()['response']
        # Use /tmp or include/ with dynamic filename
        json_path = Path("/tmp") / 'seasons.json'
        with open(json_path, 'w') as file:
            json.dump(seasons, file)
        return seasons
    else:
        return f"Error: {response.status_code}, {response.text}"

def insert_seasons():

    cursor = get_cursor()

    json_path = Path("/tmp") / 'seasons.json'

    if not json_path.exists() or json_path.stat().st_size == 0:
        raise ValueError(f"JSON file is empty for football seasons")

    # Load seasons from the file
    with open(json_path, 'r') as file:
        seasons = json.load(file)

    #  2. Walidacja zawartoÅ›ci JSON-a
    if (
        not isinstance(seasons, list) or          # Sprawdzamy, czy to jest lista
        len(seasons) == 0 or                      # Sprawdzamy, czy lista nie jest pusta
        not all(isinstance(item, (int, float)) for item in seasons)  # Sprawdzamy, czy wszystkie elementy sÄ… liczbami
    ):
        raise ValueError(f"Invalid JSON structure of football seasons")


    seasons_to_insert = [(year,) for year in seasons]

    insert_season_query = 'INSERT INTO SEASONS (SEASON_YEAR) VALUES (:season_year)'
    check_season_query = 'SELECT COUNT(*) FROM SEASONS WHERE SEASON_YEAR = :season_year'

    for season in seasons_to_insert:
        cursor.execute(check_season_query, {'season_year': season[0]})
        season_exist = cursor.fetchone()[0]

        if season_exist == 0:
            cursor.executemany(insert_season_query, [season])
            print(f'Season {season[0]} inserted.')
        else:
            print(f'Season {season[0]} already exists, skipping insertion.')
    
    close_connection()

default_args = {
    'start_date': datetime(2024, 1, 1),
    'catchup': False
}

with DAG(
    dag_id='seasons_etl_dag',
    default_args=default_args,
    description='Create all Oracle tables and fetch seasons from API',
    schedule='@yearly',
    tags=['oracle', 'etl', 'football']
) as dag:

    create_season_table_task = PythonOperator(
        task_id='create_season_table',
        python_callable=create_season_table
    )

    fetch_seasons_from_api_task = PythonOperator(
        task_id='fetch_seasons_from_api',
        python_callable=fetch_seasons_from_api
    )

    insert_seasons_task = PythonOperator(
        task_id='insert_seasons',
        python_callable=insert_seasons
    )

    create_season_table_task >> fetch_seasons_from_api_task >> insert_seasons_task